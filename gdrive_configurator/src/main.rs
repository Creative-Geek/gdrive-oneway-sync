#![windows_subsystem = "windows"]

use regex::Regex;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use thiserror::Error;

// Import the UI code generated by the build script
slint::include_modules!();

// Define a struct to verify the structure of credentials.json
#[derive(Deserialize)]
#[allow(dead_code)] // Fields are used for validation only
struct ServiceAccount {
    r#type: String,
    project_id: String,
    private_key: String,
    client_email: String,
    // We don't need all fields, just the most important ones for validation
}

// Define a struct for the output config.json
#[derive(Serialize)]
struct Config {
    local_folder_path: String,
    gdrive_folder_id: String,
}

// Custom error types for clear feedback
#[derive(Debug, Error)]
enum AppError {
    #[error("Local folder path cannot be empty.")]
    EmptyLocalPath,
    #[error("Google Drive link cannot be empty.")]
    EmptyGdriveLink,
    #[error("Credentials file path cannot be empty.")]
    EmptyCredentialsPath,
    #[error("The selected folder does not exist: {0}")]
    FolderNotFound(String),
    #[error("Invalid Google Drive folder link. It should look like '.../folders/...'")]
    InvalidGdriveLink,
    #[error("Could not read the credentials file: {0}")]
    CredentialsReadError(String),
    #[error("The credentials file is not valid JSON or is missing required fields.")]
    CredentialsParseError,
    #[error("The credentials file is not for a 'service_account'. Type found: {0}")]
    CredentialsInvalidType(String),
    #[error("Failed to save config.json: {0}")]
    ConfigSaveError(String),
    #[error("Failed to copy credentials.json: {0}")]
    CredentialsCopyError(String),
}
fn main() -> Result<(), slint::PlatformError> {

    let ui = AppWindow::new()?;
    let ui_handle = ui.as_weak();

    // --- Callback Implementations ---

    let h = ui_handle.clone();
    ui.on_browse_local_folder(move || {
        if let Some(path) = rfd::FileDialog::new().pick_folder() {
            h.unwrap()
                .set_local_path(path.to_string_lossy().to_string().into());
        }
    });

    let h = ui_handle.clone();
    ui.on_browse_credentials(move || {
        if let Some(path) = rfd::FileDialog::new()
            .add_filter("JSON", &["json"])
            .pick_file()
        {
            h.unwrap()
                .set_credentials_path(path.to_string_lossy().to_string().into());
        }
    });

    let h = ui_handle.clone();
    ui.on_save_config(move || {
        let ui = h.unwrap();
        // Reset status on each attempt
        ui.set_status_text("".into());

        match handle_save(&ui) {
            Ok(_) => {
                ui.set_status_color(slint::Brush::SolidColor(slint::Color::from_rgb_u8(34, 139, 34))); // ForestGreen
                ui.set_status_text("Success! config.json and credentials.json saved.".into());
            }
            Err(e) => {
                ui.set_status_color(slint::Brush::SolidColor(slint::Color::from_rgb_u8(220, 20, 60))); // Crimson
                ui.set_status_text(e.to_string().into());
            }
        }
    });

    ui.run()
}
// The core logic function, separated for clarity and testability
fn handle_save(ui: &AppWindow) -> Result<(), AppError> {
    let local_path = ui.get_local_path().to_string();
    let gdrive_link = ui.get_gdrive_link().to_string();
    let creds_path = ui.get_credentials_path().to_string();

    // --- 1. Basic field validation ---
    if local_path.is_empty() { return Err(AppError::EmptyLocalPath); }
    if gdrive_link.is_empty() { return Err(AppError::EmptyGdriveLink); }
    if creds_path.is_empty() { return Err(AppError::EmptyCredentialsPath); }

    // --- 2. Verify local folder exists ---
    let path = Path::new(&local_path);
    if !path.is_dir() {
        return Err(AppError::FolderNotFound(local_path));
    }

    // --- 3. Verify and extract Google Drive folder ID ---
    // This regex captures the ID from common Google Drive folder URLs
    let gdrive_regex = Regex::new(r"/folders/([a-zA-Z0-9_-]+)").unwrap();
    let gdrive_folder_id = gdrive_regex
        .captures(&gdrive_link)
        .and_then(|cap| cap.get(1))
        .map(|m| m.as_str().to_string())
        .ok_or(AppError::InvalidGdriveLink)?;

    // --- 4. Verify credentials.json file ---
    let creds_content = fs::read_to_string(&creds_path)
        .map_err(|e| AppError::CredentialsReadError(e.to_string()))?;
    let service_account: ServiceAccount =
        serde_json::from_str(&creds_content).map_err(|_| AppError::CredentialsParseError)?;

    if service_account.r#type != "service_account" {
        return Err(AppError::CredentialsInvalidType(service_account.r#type));
    }

    // --- 5. All validation passed. Create and save files. ---

    // Create the config object.
    // serde_json will correctly escape backslashes for Windows paths.
    let config = Config {
        local_folder_path: local_path,
        gdrive_folder_id,
    };

    // Serialize to a pretty-printed JSON string
    let config_json = serde_json::to_string_pretty(&config)
        .map_err(|e| AppError::ConfigSaveError(e.to_string()))?;

    // Save config.json
    fs::write("config.json", config_json)
        .map_err(|e| AppError::ConfigSaveError(e.to_string()))?;

    // Copy credentials.json
    fs::copy(&creds_path, "credentials.json")
        .map_err(|e| AppError::CredentialsCopyError(e.to_string()))?;

    Ok(())
}